# 蓝牙多设备压力测试总结报告（更新版）

## 背景

- 目标：在一台主机上同时接收多台生物信号设备（EEG/EMG/SCS）以 BLE Notify 推送的数据流，验证在高吞吐（单设备 500 Hz，通知频率 100 Hz、每包 5 帧、每帧 40B/72B）下的稳定性、丢包率与端到端延迟。
- 装置：nRF52 外设固件（SoftDevice，TIMER4 1 MHz 时间戳、环形缓冲、一次通知打包 5 帧）+ Windows 主机（Python/bleak）。
- 关键问题：单蓝牙适配器在多连接并发场景下容易出现丢包、起始阶段连接/订阅不稳定、平均延迟显著升高（队列排队）。

## 近期变更（功能与配置）

- 固件支持 16/32 通道可选：在 `firmware/main.c` 顶层通过宏 `STREAM_CHANNELS` 选择 16（默认）或 32 通道；发送侧按 MTU 预算动态控制每次通知打包帧数（避免 32 通道时超长）。
  - 16 通道：单帧 40B，默认每通知 5 帧（约 200B）。
  - 32 通道：单帧 72B，每通知最多 3 帧（约 216B）。
- 上位机解析支持通道选择：
  - 新增 `decode.decode_stream_channels(data, channels)` 与 `decode.decode_frame_channels(frame, channels)`；原有 `decode_stream` 依旧按 16 通道向后兼容。
  - `test_sync.py`、`test_write.py` 顶部新增 `EEG_CHANNELS = 16`（可改为 32）。

切换方式：
- EEG 设备（固件）：在工程编译宏中添加/修改 `STREAM_CHANNELS=32` 后重新编译并烧录；16 通道无需改动。
- 主机脚本：将 `EEG_CHANNELS` 设置为 16 或 32，与固件保持一致。

## 方法与代码技术

- 固件（`firmware/main.c`）
  - 500 Hz 定时产生 16 通道合成信号；TIMER4 微秒时间戳；按 5 帧打包至通知。
  - 发送侧环形缓冲 + 资源不足重试（处理 `NRF_ERROR_RESOURCES`）。
  - 可读状态特征值回报“最后完成帧号”，用于主机读取发送总量。
- 主机库（`blecore.py`）
  - bleak WinRT 后端包装，提供 `connect/start_notify/write/read/stop_notify/disconnect` 同步接口（内部异步）。
  - 统一日志与超时控制，必要时重试。
- 解码（`decode.py`）
  - 解析 40B/72B 帧布局：`timestamp_us:uint32` + `sequence:uint32` + N×int16（N=16/32）。支持一次通知多帧。
- 测试脚本
  - `tester.py`：单设备/顺序测试，记录每帧延迟、丢帧、CSV 导出。
  - `test_sync.py`：并发压测。为每个设备建立线程，会合并同步发送“开始”（0xAA）、结束（0xFF）。
    - 采用事件门闩：逐阶段等待全部设备“已连接”→“已订阅 notify”→广播开始。
    - 延迟计算采用“运行最小 host-device 时间差”基线，避免批内多帧导致的负值偏差：`delay = (arrival_us - ts_us) - min_delta_seen`。
    - 丢帧检测基于 `sequence` 连续性。

## 计时与延迟口径

- 到达时间：`time.perf_counter_ns()`（单调高分辨率）与脚本启动时刻作差，单位微秒。
- 设备时间戳：固件 TIMER4 微秒精度，流开始时清零。
- 延迟：同一通知批次中，多帧共用到达时间。采用“运行最小差值”作为偏置，估计链路附加排队时延，避免负值。

## 测试场景与配置

- 每台设备：500 Hz 采样、100 Hz 通知、每包 5 帧、每帧 40B → 约 20 kB/s/设备（未计 ATT 开销）。
- 主机：Windows + Python 3 + bleak（WinRT）。
- 适配器：
  1) BARROT Bluetooth 5.4 adapter
  2) Realtek Bluetooth 5.0 adapter
  3) Generic Bluetooth adapter
- 并发：单线程（1 设备）、二线程（2 设备）、三线程（3 设备）对比。

## 结果汇总与分析（基于 `resultlog.txt`）

以下为 10 s 左右运行的代表性结果（节选）：

- BARROT 5.4（500 Hz 单设备约 20 kB/s）
  - 单线程：0% 丢包；平均延迟 ≈ 19.5 ms。
  - 二线程：丢包 ≈ 29.3%；平均延迟 ≈ 150–167 ms。
  - 三线程：丢包 ≈ 50%；平均延迟 ≈ 156–215 ms。
  - 结论：并发>1 后明显拥塞，队列排队导致高延迟与丢包。

- Realtek 5.0
  - 单线程：0% 丢包；延迟 ≈ 17.6 ms。
  - 二线程：一台 ≈ 6.2% 丢包（高延迟~136 ms），另一台 0%（低延迟~5.8 ms）。
  - 三线程：两台基本 0%/低延迟（8–27 ms），一台丢包 15–35%（高延迟）。
  - 结论：总体更稳，但在三连接时仍会出现“赢家-输家”分化，说明适配器/栈在多连接调度的公平性不足。

- Generic adapter
  - 单线程：0%／低延迟 ≈ 13.4 ms。
  - 二线程：丢包 ≈ 13.6% 与 82%（后者几乎不可用）。
  - 三线程：一台 0%（低延迟），其余两台 90%+ 丢包，平均延迟 255–578 ms。
  - 结论：并发能力极差，不适合作为多设备压力测试适配器。

- 32 通道一对一（Realtek）：
  - `[bio-eeg] received=4971, sent=4971, avg_delay_us≈12.1 ms`，表现正常。

- 其他现象
  - 三连接启动阶段，经常有 1 台设备连接或订阅被放弃；完整三连成功率偏低。
  - 报错多为 `BleakDeviceNotFoundError`（WinRT 层未能找到设备或会话被系统回收），或后台 BLE 线程刚启动即异常退出。

### 混合负载测试（1×接收 + 1–2×写）

- 条件：EEG 设备 500 Hz Notify（16/32 通道），同时主机以 10 Hz 向 1–2 台“写端”设备发送 16 字节 payload（无响应写）。
- 结果：
  - 16 通道：
    - 一对一对一：EEG 0 丢包；写端 100/100 成功。
    - 一对一对二：EEG 0 丢包；两写端均 100/100 成功。起始阶段偶发掉连。
  - 32 通道：
    - 一对一对一：EEG 0 丢包；写端 100/100 成功。
    - 一对一对二：EEG 0 丢包；两写端均 100/100 成功。起始阶段偶发掉连。
- 解读：低频“无响应写”对单适配器承载的影响较小；主要瓶颈仍在多条高频 Notify 并发时的调度与传输。

### 根因研判

- 单适配器多连接时，Windows/驱动在连接事件调度与 ATT 队列上存在瓶颈与不稳定，表现为：
  - 通知累计排队：平均延迟跃升至 100–200+ ms。
  - 抢占式公平性差：部分连接明显“饿死”，丢包高。
  - 启动/订阅阶段脆弱：并发操作时更易出现设备未就绪、句柄失效、超时。
- 连接不稳定的具体原因分析：
  1) 同步并发发起 connect/CCCD 写入，争用同一适配器射频时隙与主机栈资源，导致其一两条连接被延后或超时；
  2) 连接初期同时高频通知（或数据长度/2M PHY 协商中途），GATT 队列拥堵，使 CCCD 写/数据长度更新更易失败；
  3) Windows 电源/调度影响：USB 省电、CPU 调度抖动会放大初期脆弱窗口；
  4) 适配器驱动公平性不足：多连接调度不均，某连接被“饿死”；
  5) 广播/连接参数耦合：多设备相近的广告间隔/窗口与主机连接扫描窗口重叠，增加首次连接碰撞概率。
- 固件侧在单链路下可 0 丢包，说明空口并非主要矛盾；并发退化更像主机侧（适配器/栈/驱动/系统调度）限制。

## 改进建议

### 短期（低风险、易实施）
- 连接/订阅节流：
  - 逐台执行 connect → start_notify 完成后，再进行下一台；或在 `test_sync.py` 中为第二、第三台引入 300–800 ms 的错峰延迟。
  - 对 `start_notify`、`write_characteristic` 增加指数退避重试（例如最多 3 次，200/400/800 ms 间隔）。
- 帧率与负载控制：
  - 将单设备通知频率降到 50–80 Hz（仍每包 5 帧，合计 250–400 Hz 有效帧率），或每包减少到 3–4 帧以降低瞬时突发。
  - 观察到延迟>100 ms 或连续丢帧时，动态降速（应用层流控）。
- 主机稳态优化：
  - 进程提升到“高”优先级，禁用节能；为 BLE 回调使用较小的临界区（现已很小），避免打印阻塞（已去除打印）。
  - 固定 CPU 亲和、避免与重负载任务同核。
- 写端建议：命令/心跳尽量使用“无响应写”（已在 `test_write.py` 采用），减少握手往返带来的发送限速。

## 最新验证（启动节流的效果）

- 已在 `test_sync.py` 与 `test_write.py` 中引入“启动节流”：为每个会话增加连接闸门，按顺序放行连接/订阅，并在相邻设备之间加入固定错峰时延（默认 `CONNECT_STAGGER_S = 0.6` 秒）。
- 实测结果：该方法有效解决了开始阶段的连接/订阅不稳定问题（你本次复测已确认），显著降低了“有一台设备连接被放弃”的概率，三连成功率提升明显。
- 可调建议：
  - 现场环境良好时可尝试将 `CONNECT_STAGGER_S` 调小到 0.3–0.5 秒；
  - 若偶发仍存在，建议叠加 2–3 次指数退避重试（connect/subscribe 失败后 200/400/800 ms 重试）。
  - 多适配器或迁移至 Linux/BlueZ 仍是高并发下的长期优解，但在 Windows/单适配器条件下，“启动节流”是性价比极高的稳定性改进。

### 中期（结构性改进）
- 多适配器分担：
  - 将 3 台设备分挂 2–3 个 USB 蓝牙适配器，分别由独立进程管理（Windows 下多进程彼此独立，减少内部竞争）。
  - 在 Linux（BlueZ）上测试，多连接吞吐通常更佳且更可控；可为每适配器绑定 `hciX`。
- 固件微调：
  - 扩大环形缓冲、记录高水位与丢弃计数；可选择小幅延迟每次 `try_send` 的批次推进，改善空口公平性。
  - 确认已使用 2M PHY 与 DLE（ATT_MTU/Effective PDU 最大化），连接间隔维持 7.5–15 ms。
  - 32 通道模式下维持每通知不超过 ~244B 载荷（现已自动控制）。

### 长期（平台与架构）
- 采集后移/边缘汇聚：将多设备接入到一个“汇聚节点”（例如一个 nRF52 Central 或嵌入式主机）再统一上行到 PC。
- 驱动/硬件选型：优先选择在三连接下表现良好的适配器（本轮 Realtek 明显优于 Generic；BARROT 居中）。

## 代码层面可落地的微改（可选）

- 在 `test_sync.py`：
  - 对 `connect/start_notify/write` 增加 2–3 次退避重试。
  - 在所有设备 `wait_ready` 成功前不打印“All devices ready…”，失败时立即广播 stop 并清理线程（已调整）。
  - 统计延迟分位（p50/p95/p99）并追加到 CSV/控制台，便于量化抖动与排队。
- 在固件：
  - 在通知的最后一帧后附带一个简短统计结构（缓冲高水位、丢弃次数），主机端入 CSV，快速定位瓶颈位置（空口 vs 主机）。

## 结论

- 单适配器下，单连接可稳定 0 丢包、低延迟；并发连接数 ≥ 2 时，Windows BLE 栈与适配器调度成为瓶颈，表现为高延迟与不公平丢包、连接起始不稳定。
- 通过连接/订阅节流、退避重试、降低瞬时负载，以及将写操作改为“无响应写”，可显著提升稳定性；更理想的方案是多适配器或迁移到 BlueZ/Linux。
- 16/32 通道均已验证一对一稳定；在多连接场景下，16/32 通道的主要差异体现在每通知可打包帧数不同，但核心瓶颈仍在主机侧调度与射频资源分配。

---

附：名词与数据口径
- 丢包率 = 1 − received/sent（sent 来自外设可读状态特征，表示已成功发送至 GATT 层的帧数）。
- 平均延迟为主机接收时间与外设帧时间戳差值的去偏版本（按运行最小差校准）。
